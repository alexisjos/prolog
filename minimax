#!/usr/bin/swipl
%Creation of a test-tree :
%                a
%								 |
%								 3
%             /  |  \
%           b    c    d
%					 |     |     |
%					 2     1     3
%         /|\   /|\   /|\
%        e f g h i j k l m
%			   | | | | | | | | |
%				 4 3 2 7 1 4 3 5 3


branch(a,b).
branch(a,c).
branch(a,d).
branch(b,e).
branch(b,f).
branch(b,g).
branch(c,h).
branch(c,i).
branch(c,j).
branch(d,k).
branch(d,l).
branch(d,m).

val(N,e):-N is 4.
val(N,f):-N is 3.
val(N,g):-N is 2.
val(N,h):-N is 7.
val(N,i):-N is 1.
val(N,j):-N is 4.
val(N,k):-N is 3.
val(N,l):-N is 5.
val(N,m):-N is 3.

%Rules to define minimum of a number-list :
min([A],A).
min([A|B],R):-min(B,S),R is min(A,S).

%Rules defining min of a list of sublists, each one formed by two elements, the first being a number :
%Those are used in the first minmax iteration (choice), where we wanna discover the best move, and not
%the best score.
minM([A,B],[C,_],[A,B]):-A<C.
minM([A,_],[C,D],[C,D]):-A>=C.
minM([[A,B]],[A,B]).
minM([[A,B]|C],[RA,RB]):-minM(C,S),minM([A,B],S,[RA,RB]).

%By encapsulating branch(),minimax() with evalChild(), we can use setof to create list of scores of all 
%children verifying minmax(). We will then be able to find the minimum score amongst it, using the rule min()
%previously defined. 
evalChild(Node,Score,Level):-branch(Node,Child),minimax(Child,Score,Level).

%Once the max recursion level is reached we evaluate the the leaves.
minimax(Leaf,Score,0):-val(Score,Leaf).
%While the recursion level has not been reached, keep on building the tree. The min/max alternance is acheived
%by switching the Score sign at each iteration and always calculating the minimum (Thanx wikipedia).
minimax(Node,Score,Level):-NewLev is Level-1,setof(A,evalChild(Node,A,NewLev),ScoreList),
													min(ScoreList,NewScore),Score is -NewScore.

%First predicate to evaluate, this is cut from the algorithm body to allow us to get the best move, and not
%its score as we would have obtained by calling directly minimax().
evalMove(Game,Move,MoveScore,Level):-branch(Game,Move),minimax(Move,MoveScore,Level).
choice(Game,Move,Level):-NewLev is Level-1,setof([MoveScore,Move],evalMove(Game,Move,MoveScore,NewLev),List),
												write(List),minM(List,[_,Move]).

%This algorithm may prove wrong when used with a odd heuristic (in this case we can only test 2).

%-------------------------------------------------------------------------------------------------------------

%Modelisation of a game state and of an eval function for a game :

%Regarde si la grille S peut être le tour suivant de la grille L avec l’ajout de P (rond ou croix). C est le 
%compteur qui correspond à la dernière pièce ajoutée (va de 1 à 5)

% Fonction outils
% nieme(N,X,Y) est vrai si Y est le nième element de la liste X
nieme(1, [H|_], H).
nieme(N, [_|T], Z) :-
N > 0,
N1 is N - 1,
nieme(N1, T, Z).

% On encapsule nieme pour corriger le fait que C soit < 0
niemec(N,X,Y):-N == 0,nieme(5,X,Y).
niemec(N,X,Y):-N == -1,nieme(4,X,Y).
niemec(N,X,Y):-N == -2,nieme(3,X,Y).
niemec(N,X,Y):-N == -3,nieme(2,X,Y).
niemec(N,X,Y):-(N > 0),nieme(N,X,Y).

%Same as nieme :
rang(0,X,[X|_]).
rang(N,X,[_|LB]) :- var(N),rang(M,X,LB),N is M+1.
rang(N,X,[_|LB]) :- nonvar(N),M is N-1,rang(M,X,LB).
%Negativ rank for desc 
rangc(N,Y,X):-N=<0,-N=<5,M is 5+N,rang(M,Y,X).
rangc(N,Y,X):-N>0,rang(N,Y,X).

%Jeux = [11,22,32,51,92].

desc(L,S,P,C):-
R1 is C - 1, niemec(R1,L,A1),niemec(R1,S,A1),
R2 is C - 2, niemec(R2,L,A2),niemec(R2,S,A2),
R3 is C - 3, niemec(R3,L,A3),niemec(R3,S,A3),
R4 is C - 4, niemec(R4,L,A4),niemec(R4,S,A4),
niemec(C,S,V), (V > 0), (V < 100), P is V mod 10.

%Evaluation function:
%Let 0 stand for an unused area
%Let 1 stand for the computer symbol
%Let 2 stand for the user symbol

eval(Score,Game):-win(Game),Score is 100,!.		%If "Game" is a winning move, Score is maximum
eval(Score,Game):-lose(Game),Score is -100,!.	%If "Game" is a losing move, Score is minimum
eval(Score,Game):-myTwos(Game,MT),hisTwos(Game,HT),myOnes(Game,MO),hisOnes(Game,HO),Score is MT*10+MO-HT*10-HO.

%count(Game,NT,Player,N) is true when NT is the number of lines/columns/diags where player "Player" has N marks
count(Game,NT,Player,N):-findall(X,line(Game,Player,X,N),NbL),length(NbL,L),
											findall(Y,column(Game,Player,Y,N),NbC),length(NbC,C),
											findall(Z,diag(Game,Player,Z,N),NbD),length(NbD,D),
											NT is L+C+D.
%line(Game,Player,X,N) is true if the player has N marks on line X
%same for column and diag
line(Game,Player,X,N):-
