#!/usr/bin/swipl
%Creation of a test-tree :
%                a
%								 |
%								 3
%             /  |  \
%           b    c    d
%					 |     |     |
%					 2     1     3
%         /|\   /|\   /|\
%        e f g h i j k l m
%			   | | | | | | | | |
%				 4 3 2 7 1 4 3 5 3

branch(a,b).
branch(a,c).
branch(a,d).
branch(b,e).
branch(b,f).
branch(b,g).
branch(c,h).
branch(c,i).
branch(c,j).
branch(d,k).
branch(d,l).
branch(d,m).

val(N,e):-N is 4.
val(N,f):-N is 3.
val(N,g):-N is 2.
val(N,h):-N is 7.
val(N,i):-N is 1.
val(N,j):-N is 4.
val(N,k):-N is 3.
val(N,l):-N is 5.
val(N,m):-N is 3.

%Rules to define minimum of a number-list :
min([A],A).
min([A|B],R):-min(B,S),R is min(A,S).

%Rules defining min of a list of sublists, each one formed by two elements, the first being a number :
%Those are used in the first minmax iteration (choice), where we wanna discover the best move, and not
%the best score.
minM([A,B],[C,_],[A,B]):-A<C.
minM([A,_],[C,D],[C,D]):-A>=C.
minM([[A,B]],[A,B]).
minM([[A,B]|C],[RA,RB]):-minM(C,S),minM([A,B],S,[RA,RB]).

%By encapsulating branch(),minimax() with evalChild(), we can use setof to create list of scores of all 
%children verifying minmax(). We will then be able to find the minimum score amongst it, using the rule min()
%previously defined. 
evalChild(Node,Score,Level):-branch(Node,Child),minimax(Child,Score,Level).

%Once the max recursion level is reached we evaluate the the leaves.
minimax(Leaf,Score,0):-val(Score,Leaf).
%While the recursion level has not been reached, keep on building the tree. The min/max alternance is acheived
%by switching the Score sign at each iteration and always calculating the minimum (Thanx wikipedia).
minimax(Node,Score,Level):-NewLev is Level-1,setof(A,evalChild(Node,A,NewLev),ScoreList),
													min(ScoreList,NewScore),Score is -NewScore.

%First predicate to evaluate, this is cut from the algorithm body to allow us to get the best move, and not
%its score as we would have obtained by calling directly minimax().
evalMove(Game,Move,MoveScore,Level):-branch(Game,Move),minimax(Move,MoveScore,Level).
choice(Game,Move,Level):-NewLev is Level-1,setof([MoveScore,Move],evalMove(Game,Move,MoveScore,NewLev),List),
												write(List),minM(List,[_,Move]).

%This algorithm may prove wrong when used with a odd heuristic (in this case we can only test 2).
